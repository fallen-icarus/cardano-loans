{-# OPTIONS_GHC -Wno-ambiguous-fields #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}

{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module Test.ActiveUTxOs.UpdateLenderAddress.Regressions where

import qualified Ledger.Address as LA
import qualified PlutusLedgerApi.V2 as PV2
import qualified Ledger.CardanoWallet as Mock 
import Test.Tasty (TestTree)
import Control.Monad (forM,forM_)
import Data.List (sortOn)

import CardanoLoans

import Test.Prelude

-------------------------------------------------
-- Regression Tests
-------------------------------------------------
-- | Update a single lender payment address. The new address uses a payment pubkey.
regressionTest1 :: MonadEmulator m => m ()
regressionTest1 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = 
        PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 3600
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 10_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 3_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 1
                  ]
              , outputDatum = OutputDatum $ toDatum askDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",1)
                  , (_unAssetBeacon loanBeacon,1)
                  , (_unLenderId lenderBeacon,1)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  startSlot <- currentSlot

  askRef <- 
    txOutRefWithValue $ 
      utxoValue 3_000_000 $ mconcat
        [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
        , uncurry PV2.singleton (_unAsset collateral1) 1
        ]

  offerRef <-
    txOutRefWithValue $ 
      utxoValue 4_000_000 $ mconcat
        [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
        , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
        ]

  let activeDatum = 
        createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime startSlot) offerDatum
      loanIdBeacon = genLoanId offerRef

  -- Accept the offer.
  void $ transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens = 
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",-1)
                  , ("Ask",-1)
                  , (_unAssetBeacon loanBeacon,-2)
                  , (_unLenderId lenderBeacon,-1)
                  ]
              , mintRedeemer = toRedeemer BurnNegotiationBeacons
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          , TokenMint
              { mintTokens = 
                  [ ("Active",1)
                  , (_unBorrowerId borrowerBeacon,1)
                  , (_unAssetBeacon loanBeacon,1)
                  , (_unLoanId loanIdBeacon,2)
                  ]
              , mintRedeemer = toRedeemer $ CreateActive negotiationBeaconCurrencySymbol
              , mintPolicy = toVersionedMintingPolicy activeBeaconScript
              , mintReference = Just activeRef
              }
          ]
      , inputs = 
          [ Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
          , Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId loanIdBeacon) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum activeDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress lenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId loanIdBeacon) 1 ]
              , outputDatum = 
                  OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId loanIdBeacon)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef,activeRef,loanRef]
      , extraKeyWitnesses = [borrowerPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Just startSlot
          , validityRangeUpperBound = Nothing
          }
      }

  activeUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update a single lender payment address. The new address uses another proxy address.
regressionTest2 :: MonadEmulator m => m ()
regressionTest2 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)

      newLenderCred = PV2.PubKeyCredential 
                    $ LA.unPaymentPubKeyHash
                    $ Mock.paymentPubKeyHash 
                    $ Mock.knownMockWallet 3
      newLenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash newLenderCred)

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 3600
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 10_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 3_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 1
                  ]
              , outputDatum = OutputDatum $ toDatum askDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",1)
                  , (_unAssetBeacon loanBeacon,1)
                  , (_unLenderId lenderBeacon,1)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  startSlot <- currentSlot

  askRef <- 
    txOutRefWithValue $ 
      utxoValue 3_000_000 $ mconcat
        [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
        , uncurry PV2.singleton (_unAsset collateral1) 1
        ]

  offerRef <-
    txOutRefWithValue $ 
      utxoValue 4_000_000 $ mconcat
        [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
        , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
        ]

  let activeDatum = 
        createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime startSlot) offerDatum
      loanIdBeacon = genLoanId offerRef

  -- Accept the offer.
  void $ transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens = 
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",-1)
                  , ("Ask",-1)
                  , (_unAssetBeacon loanBeacon,-2)
                  , (_unLenderId lenderBeacon,-1)
                  ]
              , mintRedeemer = toRedeemer BurnNegotiationBeacons
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          , TokenMint
              { mintTokens = 
                  [ ("Active",1)
                  , (_unBorrowerId borrowerBeacon,1)
                  , (_unAssetBeacon loanBeacon,1)
                  , (_unLoanId loanIdBeacon,2)
                  ]
              , mintRedeemer = toRedeemer $ CreateActive negotiationBeaconCurrencySymbol
              , mintPolicy = toVersionedMintingPolicy activeBeaconScript
              , mintReference = Just activeRef
              }
          ]
      , inputs = 
          [ Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
          , Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId loanIdBeacon) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum activeDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress lenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId loanIdBeacon) 1 ]
              , outputDatum = 
                  OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId loanIdBeacon)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef,activeRef,loanRef]
      , extraKeyWitnesses = [borrowerPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Just startSlot
          , validityRangeUpperBound = Nothing
          }
      }

  activeUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update multiple lender payment addresses. All loans use one asset as collateral. The key NFTs
-- are in separate UTxOs. All loans are changed to use the same address. All loans come from the
-- same borrower.
regressionTest3 :: MonadEmulator m => m ()
regressionTest3 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update multiple lender payment addresses. All loans use one asset as collateral. The key NFTs
-- are in one UTxO. All loans are changed to use the same address. All loans come from the same
-- borrower.
regressionTest4 :: MonadEmulator m => m ()
regressionTest4 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  -- Consolidate the key NFTs.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip map keyUTxOs $ \(keyRef,_) ->
          Input
            { inputId = keyRef
            , inputWitness = 
                SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
            }
      , outputs = 
          [ 
            Output
              { outputAddress = toCardanoApiAddress lenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat $
                  flip map activeUTxOs $ \(_,Just ActiveDatum{_loanId}) ->
                    PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
              , outputDatum = OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,"")
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Nothing
          }
      }

  newKeyUTxO <- fmap head $ fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = mconcat
          [ flip map activeUTxOs $ \(activeUtxoRef,_) ->
              Input
                { inputId = activeUtxoRef
                , inputWitness = 
                    SpendWithPlutusReference loanRef InlineDatum $ toRedeemer $ 
                      UpdateLenderAddress newLenderAddr 0
                }
          , [ Input
                { inputId = fst newKeyUTxO
                , inputWitness = 
                    SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
                }
            ]
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update multiple lender payment addresses. All loans use one asset as collateral. The key NFTs
-- are in separate UTxOs. All loans are changed to use different addresses. All loans come from the
-- same borrower.
regressionTest5 :: MonadEmulator m => m ()
regressionTest5 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr1 = PV2.Address lenderCred Nothing
      newLenderAddr2 =
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash borrowerCred)
      newLenderAddr3 = PV2.Address borrowerCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap (zip acs [1::Int ..3]) $ 
        \((_,Just ad@ActiveDatum{..}),i) ->
          let addr = if i == 1 then newLenderAddr1
                     else if i == 2 then newLenderAddr2
                     else newLenderAddr3
          in 
            [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = addr}
                , outputReferenceScript = toReferenceScript Nothing
                }
            , Output
                { outputAddress = toCardanoApiAddress addr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
                , outputDatum = 
                    OutputDatum $ toDatum $ 
                      PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
            ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact 
    lenderPersonalAddr 
    [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] 
    [lenderPayPrivKey]
    emptyTxParams
      { inputs = mconcat
          [ flip map (zip activeUTxOs [1::Int ..3]) $ \((activeUtxoRef,_),i) ->
              Input
                { inputId = activeUtxoRef
                , inputWitness = 
                    SpendWithPlutusReference loanRef InlineDatum $ toRedeemer $ 
                      flip UpdateLenderAddress 0 $ 
                        if i == 1 then newLenderAddr1
                        else if i == 2 then newLenderAddr2
                        else newLenderAddr3
                }
          , flip map keyUTxOs $ \(keyRef,_) ->
              Input
                { inputId = keyRef
                , inputWitness = 
                    SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
                }
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update multiple lender payment addresses. All loans use one asset as collateral. The key NFTs
-- are in one UTxO. All loans are changed to use different addresses. All loans come from the same
-- borrower.
regressionTest6 :: MonadEmulator m => m ()
regressionTest6 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr1 = PV2.Address lenderCred Nothing
      newLenderAddr2 =
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash borrowerCred)
      newLenderAddr3 = PV2.Address borrowerCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  -- Consolidate the key NFTs.
  void $ transact 
    lenderPersonalAddr 
    [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] 
    [lenderPayPrivKey]
    emptyTxParams
      { inputs = flip map keyUTxOs $ \(keyRef,_) ->
          Input
            { inputId = keyRef
            , inputWitness = 
                SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
            }
      , outputs = 
          [ 
            Output
              { outputAddress = toCardanoApiAddress lenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat $
                  flip map activeUTxOs $ \(_,Just ActiveDatum{_loanId}) ->
                    PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
              , outputDatum = OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,"")
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Nothing
          }
      }

  newKeyUTxO <- fmap head $ fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap (zip acs [1::Int ..3]) $ 
        \((_,Just ad@ActiveDatum{..}),i) ->
          let addr = if i == 1 then newLenderAddr1
                     else if i == 2 then newLenderAddr2
                     else newLenderAddr3
          in 
            [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = addr}
                , outputReferenceScript = toReferenceScript Nothing
                }
            , Output
                { outputAddress = toCardanoApiAddress addr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
                , outputDatum = 
                    OutputDatum $ toDatum $ 
                      PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
            ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact 
    lenderPersonalAddr 
    [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] 
    [lenderPayPrivKey]
    emptyTxParams
      { inputs = mconcat
          [ flip map (zip activeUTxOs [1::Int ..3]) $ \((activeUtxoRef,_),i) ->
              Input
                { inputId = activeUtxoRef
                , inputWitness = 
                    SpendWithPlutusReference loanRef InlineDatum $ toRedeemer $ 
                      flip UpdateLenderAddress 0 $ 
                        if i == 1 then newLenderAddr1
                        else if i == 2 then newLenderAddr2
                        else newLenderAddr3
                }
          , [ Input
                { inputId = fst newKeyUTxO
                , inputWitness = 
                    SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
                }
            ]
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update multiple lender payment addresses. All loans use one asset as collateral. The key NFTs
-- are in separate UTxOs. All loans are changed to use the same address. All loans come from
-- different borrowers.
regressionTest7 :: MonadEmulator m => m ()
regressionTest7 = do
  let -- Borrower1 Info
      borrowerWallet1 = Mock.knownMockWallet 1
      borrowerPersonalAddr1 = Mock.mockWalletAddress borrowerWallet1
      borrowerPayPrivKey1 = Mock.paymentPrivateKey borrowerWallet1
      borrowerPubKey1 = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet1
      borrowerCred1 = PV2.PubKeyCredential borrowerPubKey1
      borrowerBeacon1 = genBorrowerId borrowerCred1
      loanAddress1 = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred1)

      -- Borrower2 Info
      borrowerWallet2 = Mock.knownMockWallet 3
      borrowerPersonalAddr2 = Mock.mockWalletAddress borrowerWallet2
      borrowerPayPrivKey2 = Mock.paymentPrivateKey borrowerWallet2
      borrowerPubKey2 = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet2
      borrowerCred2 = PV2.PubKeyCredential borrowerPubKey2
      borrowerBeacon2 = genBorrowerId borrowerCred2
      loanAddress2 = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred2)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum1 = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred1
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      askDatum2 = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred2
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet1 900_000_000 [("TestToken1",1000)]
  mintTestTokens borrowerWallet2 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr1 [refScriptAddress] [borrowerPayPrivKey1] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred1
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 1
          Output
            { outputAddress = loanAddress1
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum1
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey1]
      }

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr2 [refScriptAddress] [borrowerPayPrivKey2] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred2
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 1
          Output
            { outputAddress = loanAddress2
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum2
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey2]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",2)
                  , (_unAssetBeacon loanBeacon,2)
                  , (_unLenderId lenderBeacon,2)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress1
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = loanAddress2
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs1 <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress1
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs1 <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress1
      (negotiationBeaconCurrencySymbol,"Offer")

  askUTxOs2 <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress2
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs2 <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress2
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon,_borrowerId}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId _borrowerId,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs borrowerCred loanAddress start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress,_borrowerId} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs1) (grouped 5 askUTxOs1)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr1 [loanAddress1,refScriptAddress] [borrowerPayPrivKey1] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs borrowerCred1 loanAddress1 startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey1]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs2) (grouped 5 askUTxOs2)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr2 [loanAddress2,refScriptAddress] [borrowerPayPrivKey2] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs borrowerCred2 loanAddress2 startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey2]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs1 <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress1
      (activeBeaconCurrencySymbol,"Active")

  activeUTxOs2 <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress2
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs1 <- fmap concat $ forM activeUTxOs1 $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  keyUTxOs2 <- fmap concat $ forM activeUTxOs2 $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let activeUTxOs = sortOn (fst . fst) $ 
        (map (,loanAddress1) activeUTxOs1) <> (map (,loanAddress2) activeUTxOs2)
      keyUTxOs = keyUTxOs1 <> keyUTxOs2
      samplePayments acs = flip concatMap acs $ 
        \((_,Just ad@ActiveDatum{..}),loanAddress) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact 
    lenderPersonalAddr 
    [toCardanoApiAddress lenderAddr,loanAddress1,loanAddress2,refScriptAddress] 
    [lenderPayPrivKey]
    emptyTxParams
      { inputs = mconcat
          [ flip map activeUTxOs $ \((activeUtxoRef,_),_) ->
              Input
                { inputId = activeUtxoRef
                , inputWitness = 
                    SpendWithPlutusReference loanRef InlineDatum $ toRedeemer $ 
                      UpdateLenderAddress newLenderAddr 0
                }
          , flip map keyUTxOs $ \(keyRef,_) ->
              Input
                { inputId = keyRef
                , inputWitness = 
                    SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
                }
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update multiple lender payment addresses. All loans use one asset as collateral. The key NFTs
-- are in one UTxO. All loans are changed to use the same address. All loans come from
-- different borrowers.
regressionTest8 :: MonadEmulator m => m ()
regressionTest8 = do
  let -- Borrower1 Info
      borrowerWallet1 = Mock.knownMockWallet 1
      borrowerPersonalAddr1 = Mock.mockWalletAddress borrowerWallet1
      borrowerPayPrivKey1 = Mock.paymentPrivateKey borrowerWallet1
      borrowerPubKey1 = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet1
      borrowerCred1 = PV2.PubKeyCredential borrowerPubKey1
      borrowerBeacon1 = genBorrowerId borrowerCred1
      loanAddress1 = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred1)

      -- Borrower2 Info
      borrowerWallet2 = Mock.knownMockWallet 3
      borrowerPersonalAddr2 = Mock.mockWalletAddress borrowerWallet2
      borrowerPayPrivKey2 = Mock.paymentPrivateKey borrowerWallet2
      borrowerPubKey2 = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet2
      borrowerCred2 = PV2.PubKeyCredential borrowerPubKey2
      borrowerBeacon2 = genBorrowerId borrowerCred2
      loanAddress2 = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred2)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum1 = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred1
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      askDatum2 = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred2
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet1 900_000_000 [("TestToken1",1000)]
  mintTestTokens borrowerWallet2 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr1 [refScriptAddress] [borrowerPayPrivKey1] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred1
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 1
          Output
            { outputAddress = loanAddress1
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum1
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey1]
      }

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr2 [refScriptAddress] [borrowerPayPrivKey2] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred2
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 1
          Output
            { outputAddress = loanAddress2
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum2
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey2]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",2)
                  , (_unAssetBeacon loanBeacon,2)
                  , (_unLenderId lenderBeacon,2)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress1
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = loanAddress2
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs1 <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress1
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs1 <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress1
      (negotiationBeaconCurrencySymbol,"Offer")

  askUTxOs2 <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress2
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs2 <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress2
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon,_borrowerId}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId _borrowerId,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs borrowerCred loanAddress start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress,_borrowerId} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs1) (grouped 5 askUTxOs1)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr1 [loanAddress1,refScriptAddress] [borrowerPayPrivKey1] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs borrowerCred1 loanAddress1 startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey1]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs2) (grouped 5 askUTxOs2)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr2 [loanAddress2,refScriptAddress] [borrowerPayPrivKey2] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs borrowerCred2 loanAddress2 startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey2]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs1 <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress1
      (activeBeaconCurrencySymbol,"Active")

  activeUTxOs2 <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress2
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs1 <- fmap concat $ forM activeUTxOs1 $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  keyUTxOs2 <- fmap concat $ forM activeUTxOs2 $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let activeUTxOs = sortOn (fst . fst) $ 
        (map (,loanAddress1) activeUTxOs1) <> (map (,loanAddress2) activeUTxOs2)

  -- Consolidate the key NFTs.
  void $ transact 
    lenderPersonalAddr 
    [toCardanoApiAddress lenderAddr,refScriptAddress] 
    [lenderPayPrivKey]
    emptyTxParams
      { inputs = flip map (keyUTxOs1 <> keyUTxOs2) $ \(keyRef,_) ->
          Input
            { inputId = keyRef
            , inputWitness = 
                SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
            }
      , outputs = 
          [ 
            Output
              { outputAddress = toCardanoApiAddress lenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat $
                  flip map activeUTxOs $ \((_,Just ActiveDatum{_loanId}),_) ->
                    PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
              , outputDatum = OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,"")
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Nothing
          }
      }

  newKeyUTxO <- fmap head $ fmap concat $ forM activeUTxOs $ \((_,Just ad@ActiveDatum{_loanId}),_) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap acs $ 
        \((_,Just ad@ActiveDatum{..}),loanAddress) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact 
    lenderPersonalAddr 
    [toCardanoApiAddress lenderAddr,loanAddress1,loanAddress2,refScriptAddress] 
    [lenderPayPrivKey]
    emptyTxParams
      { inputs = mconcat
          [ flip map activeUTxOs $ \((activeUtxoRef,_),_) ->
              Input
                { inputId = activeUtxoRef
                , inputWitness = 
                    SpendWithPlutusReference loanRef InlineDatum $ toRedeemer $ 
                      UpdateLenderAddress newLenderAddr 0
                }
          , [ Input
                { inputId = fst newKeyUTxO
                , inputWitness = 
                    SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
                }
            ]
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | Update a single lender payment address. The deposit is increased by 1 ADA.
regressionTest9 :: MonadEmulator m => m ()
regressionTest9 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = 
        PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 3600
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 10_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",1),(_unAssetBeacon loanBeacon,1)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 3_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 1
                  ]
              , outputDatum = OutputDatum $ toDatum askDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",1)
                  , (_unAssetBeacon loanBeacon,1)
                  , (_unLenderId lenderBeacon,1)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                  , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                  ]
              , outputDatum = OutputDatum $ toDatum offerDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  startSlot <- currentSlot

  askRef <- 
    txOutRefWithValue $ 
      utxoValue 3_000_000 $ mconcat
        [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
        , uncurry PV2.singleton (_unAsset collateral1) 1
        ]

  offerRef <-
    txOutRefWithValue $ 
      utxoValue 4_000_000 $ mconcat
        [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
        , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
        , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
        ]

  let activeDatum = 
        createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime startSlot) offerDatum
      loanIdBeacon = genLoanId offerRef

  -- Accept the offer.
  void $ transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens = 
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",-1)
                  , ("Ask",-1)
                  , (_unAssetBeacon loanBeacon,-2)
                  , (_unLenderId lenderBeacon,-1)
                  ]
              , mintRedeemer = toRedeemer BurnNegotiationBeacons
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          , TokenMint
              { mintTokens = 
                  [ ("Active",1)
                  , (_unBorrowerId borrowerBeacon,1)
                  , (_unAssetBeacon loanBeacon,1)
                  , (_unLoanId loanIdBeacon,2)
                  ]
              , mintRedeemer = toRedeemer $ CreateActive negotiationBeaconCurrencySymbol
              , mintPolicy = toVersionedMintingPolicy activeBeaconScript
              , mintReference = Just activeRef
              }
          ]
      , inputs = 
          [ Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
          , Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
          ]
      , outputs =
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId loanIdBeacon) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum activeDatum
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress lenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId loanIdBeacon) 1 ]
              , outputDatum = 
                  OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId loanIdBeacon)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]
      , referenceInputs = [negotiationRef,activeRef,loanRef]
      , extraKeyWitnesses = [borrowerPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Just startSlot
          , validityRangeUpperBound = Nothing
          }
      }

  activeUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let samplePayments acs = flip concatMap acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          [ Output
              { outputAddress = loanAddress
              , outputValue = utxoValue 5_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                  , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                  , uncurry PV2.singleton (_unAsset collateral1) 10
                  ]
              , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
              , outputReferenceScript = toReferenceScript Nothing
              }
          , Output
              { outputAddress = toCardanoApiAddress newLenderAddr
              , outputValue = utxoValue 4_000_000 $ mconcat
                  [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
              , outputDatum = 
                  OutputDatum $ toDatum $ 
                    PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
              , outputReferenceScript = toReferenceScript Nothing
              }
          ]

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum $ toRedeemer $ 
                    UpdateLenderAddress newLenderAddr 1_000_000
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = samplePayments activeUTxOs
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | When updating multiple lender addresses, the collateral outputs are grouped together, and are
-- before the key outputs which are also grouped together.
regressionTest10 :: MonadEmulator m => m ()
regressionTest10 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let sampleCollateral acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                , uncurry PV2.singleton (_unAsset collateral1) 10
                ]
            , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
            , outputReferenceScript = toReferenceScript Nothing
            }

  let sampleKeys acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = toCardanoApiAddress newLenderAddr
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
            , outputDatum = 
                OutputDatum $ toDatum $ 
                  PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
            , outputReferenceScript = toReferenceScript Nothing
            }

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = mconcat
          [ sampleCollateral activeUTxOs
          , sampleKeys activeUTxOs
          ]
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | When updating multiple lender addresses, the collateral outputs are grouped together, and are
-- after the key outputs which are also grouped together.
regressionTest11 :: MonadEmulator m => m ()
regressionTest11 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let sampleCollateral acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                , uncurry PV2.singleton (_unAsset collateral1) 10
                ]
            , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
            , outputReferenceScript = toReferenceScript Nothing
            }

  let sampleKeys acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = toCardanoApiAddress newLenderAddr
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
            , outputDatum = 
                OutputDatum $ toDatum $ 
                  PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
            , outputReferenceScript = toReferenceScript Nothing
            }

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = mconcat
          [ sampleKeys activeUTxOs
          , sampleCollateral activeUTxOs
          ]
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | When updating multiple lender addresses, the collateral outputs are grouped together, and are
-- sandwiched between two groups of key outputs.
regressionTest12 :: MonadEmulator m => m ()
regressionTest12 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let sampleCollateral acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                , uncurry PV2.singleton (_unAsset collateral1) 10
                ]
            , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
            , outputReferenceScript = toReferenceScript Nothing
            }

  let sampleKeys acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = toCardanoApiAddress newLenderAddr
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
            , outputDatum = 
                OutputDatum $ toDatum $ 
                  PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
            , outputReferenceScript = toReferenceScript Nothing
            }

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = mconcat
          [ take 1 $ sampleKeys activeUTxOs
          , sampleCollateral activeUTxOs
          , drop 1 $ sampleKeys activeUTxOs
          ]
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-- | When updating multiple lender addresses, the key outputs are grouped together, and are
-- sandwiched between two groups of collateral outputs.
regressionTest13 :: MonadEmulator m => m ()
regressionTest13 = do
  let -- Borrower Info
      borrowerWallet = Mock.knownMockWallet 1
      borrowerPersonalAddr = Mock.mockWalletAddress borrowerWallet
      borrowerPayPrivKey = Mock.paymentPrivateKey borrowerWallet
      borrowerPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash borrowerWallet
      borrowerCred = PV2.PubKeyCredential borrowerPubKey
      borrowerBeacon = genBorrowerId borrowerCred
      loanAddress = toCardanoApiAddress $
        PV2.Address (PV2.ScriptCredential $ scriptHash loanScript) 
                    (Just $ PV2.StakingHash borrowerCred)

      -- Lender Info
      lenderWallet = Mock.knownMockWallet 2
      lenderPersonalAddr = Mock.mockWalletAddress lenderWallet
      lenderPayPrivKey = Mock.paymentPrivateKey lenderWallet
      lenderPubKey = LA.unPaymentPubKeyHash $ Mock.paymentPubKeyHash lenderWallet
      lenderCred = PV2.PubKeyCredential lenderPubKey
      lenderBeacon = genLenderId lenderCred
      lenderAddr = 
        PV2.Address (PV2.ScriptCredential $ scriptHash proxyScript) 
                    (Just $ PV2.StakingHash lenderCred)
      newLenderAddr = PV2.Address lenderCred Nothing

      -- Loan Info
      loanAsset = Asset (adaSymbol,adaToken)
      collateral1 = Asset (testTokenSymbol,"TestToken1")
      loanBeacon = genLoanAssetBeaconName loanAsset
      askDatum = unsafeCreateAskDatum $ NewAskInfo
        { _borrowerId = borrowerCred
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _loanTerm = 3600
        , _collateral = [collateral1]
        }
      offerDatum = unsafeCreateOfferDatum $ NewOfferInfo
        { _lenderId = lenderCred
        , _lenderAddress = lenderAddr
        , _loanAsset = loanAsset
        , _loanPrincipal = 10_000_000
        , _compoundFrequency = Nothing
        , _loanTerm = 10000
        , _loanInterest = Fraction (1,10)
        , _minPayment = 0
        , _penalty = NoPenalty
        , _collateralization = [(collateral1,Fraction(1,1_000_000))]
        , _collateralIsSwappable = False
        , _claimPeriod = 3600
        , _offerDeposit = 4_000_000
        , _offerExpiration = Nothing
        }

  -- Initialize scenario
  References{negotiationRef,activeRef,loanRef,addressUpdateObserverRef,proxyRef} <- initializeReferenceScripts 
  mintTestTokens borrowerWallet 900_000_000 [("TestToken1",1000)]

  -- Create the Ask UTxO.
  void $ transact borrowerPersonalAddr [refScriptAddress] [borrowerPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = [("Ask",3),(_unAssetBeacon loanBeacon,3)]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateAsk borrowerCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 3_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Ask" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , uncurry PV2.singleton (_unAsset collateral1) 1
                ]
            , outputDatum = OutputDatum $ toDatum askDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [borrowerPubKey]
      }

  -- Create the Offer UTxO.
  void $ transact lenderPersonalAddr [refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { tokens =
          [ TokenMint
              { mintTokens = 
                  [ ("Offer",3)
                  , (_unAssetBeacon loanBeacon,3)
                  , (_unLenderId lenderBeacon,3)
                  ]
              , mintRedeemer = toRedeemer $ CreateCloseOrUpdateOffer lenderCred
              , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
              , mintReference = Just negotiationRef
              }
          ]
      , outputs = replicate 3
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton negotiationBeaconCurrencySymbol "Offer" 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unAssetBeacon loanBeacon) 1
                , PV2.singleton negotiationBeaconCurrencySymbol (_unLenderId lenderBeacon) 1
                , uncurry PV2.singleton (_unAsset loanAsset) 10_000_000
                ]
            , outputDatum = OutputDatum $ toDatum offerDatum
            , outputReferenceScript = toReferenceScript Nothing
            }
      , referenceInputs = [negotiationRef]
      , extraKeyWitnesses = [lenderPubKey]
      }

  askUTxOs <-
    txOutRefsAndDatumsAtAddressWithBeacon @AskDatum 
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Ask")

  offerUTxOs <- 
    txOutRefsAndDatumsAtAddressWithBeacon @OfferDatum
      loanAddress 
      (negotiationBeaconCurrencySymbol,"Offer")

  let sampleBurns os as = concat $ (flip . flip zipWith) os as $
        \(offerRef,Just OfferDatum{_assetBeacon=oLoanBeacon,_lenderId}) 
         (_,Just AskDatum{_assetBeacon=aLoanBeacon}) ->
            [ TokenMint
                { mintTokens = 
                    [ ("Offer",-1)
                    , ("Ask",-1)
                    , (_unAssetBeacon oLoanBeacon,-1)
                    , (_unAssetBeacon aLoanBeacon,-1)
                    , (_unLenderId _lenderId,-1)
                    ]
                , mintRedeemer = toRedeemer BurnNegotiationBeacons
                , mintPolicy = toVersionedMintingPolicy negotiationBeaconScript
                , mintReference = Just negotiationRef
                }
            , TokenMint
                { mintTokens = 
                    [ ("Active",1)
                    , (_unBorrowerId borrowerBeacon,1)
                    , (_unAssetBeacon oLoanBeacon,1)
                    , (_unLoanId $ genLoanId offerRef,2)
                    ]
                , mintRedeemer = toRedeemer $ 
                    CreateActive negotiationBeaconCurrencySymbol
                , mintPolicy = toVersionedMintingPolicy activeBeaconScript
                , mintReference = Just activeRef
                }
            ]

      sampleOutputs start os = flip concatMap os $ 
        \(offerRef,Just od@OfferDatum{_assetBeacon}) ->
          let activeDatum@ActiveDatum{_loanId,_lenderAddress} = 
                createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) offerDatum
          in [ Output
                { outputAddress = loanAddress
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId borrowerBeacon) 1
                    , PV2.singleton activeBeaconCurrencySymbol (_unLoanId $ genLoanId offerRef) 1
                    , uncurry PV2.singleton (_unAsset collateral1) 10
                    ]
                , outputDatum = OutputDatum $ toDatum $ 
                    createAcceptanceDatumFromOffer borrowerCred offerRef (slotToPosixTime start) od
                , outputReferenceScript = toReferenceScript Nothing
                }
             , Output
                { outputAddress = toCardanoApiAddress lenderAddr
                , outputValue = utxoValue 4_000_000 $ mconcat
                    [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1 ]
                , outputDatum = 
                    OutputDatum $ toDatum $ PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
                , outputReferenceScript = toReferenceScript Nothing
                }
             ]

      sampleInputs os as = concat $
        [ flip map os $ \(offerRef,_) ->
            Input
              { inputId = offerRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        , flip map as $ \(askRef,_) ->
            Input
              { inputId = askRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
              }
        ]
      
  -- Accept the offers.
  forM_ (zip (grouped 5 offerUTxOs) (grouped 5 askUTxOs)) $ \(offers,asks) -> do
      startSlot <- currentSlot

      transact borrowerPersonalAddr [loanAddress,refScriptAddress] [borrowerPayPrivKey] $
        emptyTxParams
          { tokens = sampleBurns offers asks
          , inputs = 
              concat $ (flip . flip zipWith) offers asks $ \(offerRef,_) (askRef,_) ->
                [ Input
                    { inputId = offerRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                , Input
                    { inputId = askRef
                    , inputWitness = 
                        SpendWithPlutusReference loanRef InlineDatum (toRedeemer AcceptOffer)
                    }
                ]
          , outputs = sampleOutputs startSlot offers
          , referenceInputs = [negotiationRef,activeRef,loanRef]
          , extraKeyWitnesses = [borrowerPubKey]
          , validityRange = ValidityRange
              { validityRangeLowerBound = Just startSlot
              , validityRangeUpperBound = Nothing
              }
          }

  activeUTxOs <- take 3 <$> 
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      loanAddress 
      (activeBeaconCurrencySymbol,"Active")

  keyUTxOs <- fmap concat $ forM activeUTxOs $ \(_,Just ad@ActiveDatum{_loanId}) ->
    txOutRefsAndDatumsAtAddressWithBeacon @ActiveDatum 
      (toCardanoApiAddress lenderAddr) 
      (activeBeaconCurrencySymbol,_unLoanId _loanId)

  let sampleCollateral acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = loanAddress
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol "Active" 1
                , PV2.singleton activeBeaconCurrencySymbol (_unAssetBeacon _assetBeacon) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unBorrowerId _borrowerId) 1
                , PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1
                , uncurry PV2.singleton (_unAsset collateral1) 10
                ]
            , outputDatum = OutputDatum $ toDatum @ActiveDatum ad{_lenderAddress = newLenderAddr}
            , outputReferenceScript = toReferenceScript Nothing
            }

  let sampleKeys acs = flip map acs $ 
        \(_,Just ad@ActiveDatum{..}) ->
          Output
            { outputAddress = toCardanoApiAddress newLenderAddr
            , outputValue = utxoValue 4_000_000 $ mconcat
                [ PV2.singleton activeBeaconCurrencySymbol (_unLoanId _loanId) 1]
            , outputDatum = 
                OutputDatum $ toDatum $ 
                  PaymentDatum (activeBeaconCurrencySymbol,_unLoanId _loanId)
            , outputReferenceScript = toReferenceScript Nothing
            }

  updateSlot <- (1+) <$> currentSlot

  -- Try to update the lender's address.
  void $ transact lenderPersonalAddr [toCardanoApiAddress lenderAddr,loanAddress,refScriptAddress] [lenderPayPrivKey] $
    emptyTxParams
      { inputs = flip concatMap (zip activeUTxOs keyUTxOs) $ \((activeUtxoRef,_),(keyRef,_)) ->
          [ Input
              { inputId = activeUtxoRef
              , inputWitness = 
                  SpendWithPlutusReference loanRef InlineDatum (toRedeemer $ UpdateLenderAddress newLenderAddr 0)
              }
          , Input
              { inputId = keyRef
              , inputWitness = 
                  SpendWithPlutusReference proxyRef InlineDatum (toRedeemer ())
              }
          ]
      , outputs = mconcat
          [ take 1 $ sampleCollateral activeUTxOs
          , sampleKeys activeUTxOs
          , drop 1 $ sampleCollateral activeUTxOs
          ]
      , withdrawals =
          [ Withdrawal
              { withdrawalCredential = PV2.ScriptCredential $ scriptHash addressUpdateObserverScript
              , withdrawalAmount = 0
              , withdrawalWitness = 
                  StakeWithPlutusReference addressUpdateObserverRef $ 
                    toRedeemer ObserveAddressUpdate
              }
          ]
      , referenceInputs = [addressUpdateObserverRef,loanRef,proxyRef]
      , extraKeyWitnesses = [lenderPubKey]
      , validityRange = ValidityRange
          { validityRangeLowerBound = Nothing
          , validityRangeUpperBound = Just updateSlot
          }
      }

-------------------------------------------------
-- TestTree
-------------------------------------------------
-- | A `TestTree` containing all regression scenarios for updating lender addresses.
tests :: [TestTree]
tests =
  [ mustSucceed "regressionTest1" regressionTest1
  , mustSucceed "regressionTest2" regressionTest2
  , mustSucceed "regressionTest3" regressionTest3
  , mustSucceed "regressionTest4" regressionTest4
  , mustSucceed "regressionTest5" regressionTest5
  , mustSucceed "regressionTest6" regressionTest6
  , mustSucceed "regressionTest7" regressionTest7
  , mustSucceed "regressionTest8" regressionTest8
  , mustSucceed "regressionTest9" regressionTest9
  , mustSucceed "regressionTest10" regressionTest10
  , mustSucceed "regressionTest11" regressionTest11
  , mustSucceed "regressionTest12" regressionTest12
  , mustSucceed "regressionTest13" regressionTest13
  ]
